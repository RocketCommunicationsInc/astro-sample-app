<link rel="import" href="/bower_components/polymer/polymer.html">



<script>

		class RuxIconLibrary extends Polymer.Element {
			static get is() { return 'rux-icon-library'; }
			static get properties() {
				return {
					name: {
						type: String,
						observer: '_nameChanged'
					},
					size: {
						type: String
					}
				}
			}


		constructor() {
			super();

			this._iconSets = Object.create(null);

			//
			this._updateIconListener = this._setIcon.bind(this);
		}


		connectedCallback() {
				super.connectedCallback();
				window.addEventListener('set-icon', this._updateIconListener);
		}


		disconnectedCallback() {
			super.disconnectedCallback();
			window.removeEventListener('set-icon', this._updateIconListener);
		}



		ready() {
			super.ready();
		}

		

		_setIcon(e) {
			
			let _icon = e.detail;
			
			
			
			if(this.name && _icon.library && (this.name === _icon.library)) {
				console.log(this.name);
				console.log(this.size);
				console.log('_icon',_icon.icon);

				let sourceSvg = this.querySelectorAll(`#${_icon.icon}`)[0];
				if(sourceSvg) {

					if(!this.size) this.size = "114";

					let content = sourceSvg.cloneNode(true);
					let svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
							svg.setAttribute('viewBox', `0 0 ${this.size} ${this.size}`);
							svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
							if(_icon.library === 'status') {
								svg.setAttribute('class', 'rux-icon--status');
							}
							svg.setAttribute('focusable', 'false');
							svg.appendChild(content);

					e.detail.el.root.insertBefore(svg, null);
				}
			}
		}

		

		_nameChanged() {
			console.info('Icon Library Name Changed:',this.name);
		}
	}

		customElements.define(RuxIconLibrary.is, RuxIconLibrary);
	</script>